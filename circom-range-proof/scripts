const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// CÃ¡c range size cáº§n measure
let RANGE_SIZES = [64, 128, 256, 512, 1024];

// CLI parsing Ä‘Æ¡n giáº£n: --range 32 hoáº·c --ranges 8,16,32
for (let i = 2; i < process.argv.length; i++) {
    const arg = process.argv[i];
    if (arg === '--range' && process.argv[i + 1]) {
        const v = parseInt(process.argv[i + 1], 10);
        if (!isNaN(v)) RANGE_SIZES = [v];
    }
    if (arg.startsWith('--range=')) {
        const v = parseInt(arg.split('=')[1], 10);
        if (!isNaN(v)) RANGE_SIZES = [v];
    }
    if (arg === '--ranges' && process.argv[i + 1]) {
        const arr = String(process.argv[i + 1]).split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n));
        if (arr.length) RANGE_SIZES = arr;
    }
    if (arg.startsWith('--ranges=')) {
        const arr = String(arg.split('=')[1]).split(',').map(s => parseInt(s.trim(), 10)).filter(n => !isNaN(n));
        if (arr.length) RANGE_SIZES = arr;
    }
}

// HÃ m measure thá»i gian thá»±c thi
function measureExecutionTime(command, description) {
    console.log(`   ${description}...`);
    const startTime = process.hrtime.bigint();
    
    try {
        execSync(command, { stdio: 'pipe' });
        const endTime = process.hrtime.bigint();
        const executionTime = Number(endTime - startTime) / 1000000; // Convert to milliseconds
        console.log(`   Completed in ${executionTime.toFixed(2)}ms`);
        return executionTime;
    } catch (error) {
        console.error(`   Failed: ${error.message}`);
        return null;
    }
}

// Helper: tÃ­nh median/p95
function percentile(arr, p) {
    if (!arr.length) return NaN;
    const a = [...arr].sort((x, y) => x - y);
    const idx = (p / 100) * (a.length - 1);
    const lo = Math.floor(idx);
    const hi = Math.ceil(idx);
    if (lo === hi) return a[lo];
    return a[lo] + (a[hi] - a[lo]) * (idx - lo);
}
function median(arr) { return percentile(arr, 50); }
function p95(arr) { return percentile(arr, 95); }

// Helper: build witness má»™t láº§n trong process
async function buildWitnessOnce(rangeSize, inputPath) {
    const wasmPath = path.join(process.cwd(), `RangeProof_${rangeSize}_js`, `RangeProof_${rangeSize}.wasm`);
    const wcPath = path.join(process.cwd(), `RangeProof_${rangeSize}_js`, 'witness_calculator.js');
    if (!fs.existsSync(wasmPath) || !fs.existsSync(wcPath)) {
        throw new Error(`Missing wasm or witness_calculator for RangeProof_${rangeSize}`);
    }
    const wc = require(wcPath);
    const buffer = fs.readFileSync(wasmPath);
    const calculator = await wc(buffer);
    const input = JSON.parse(fs.readFileSync(inputPath, 'utf8'));
    const wtnsBin = await calculator.calculateWTNSBin(input, 0);
    const witnessFile = path.join(process.cwd(), `witness_${rangeSize}.wtns`);
    fs.writeFileSync(witnessFile, wtnsBin);
    return witnessFile;
}

// Helper: láº¥y sá»‘ rÃ ng buá»™c vÃ  Æ°á»›c lÆ°á»£ng báº­c FFT
function getConstraintsAndFft(rangeSize) {
    try {
        const info = execSync(`snarkjs r1cs info RangeProof_${rangeSize}.r1cs`, { stdio: 'pipe' }).toString();
        const m = info.match(/Constraints:\s*(\d+)/i);
        const signalsMatch = info.match(/# of signals:\s*(\d+)/i);
        const constraints = m ? parseInt(m[1], 10) : NaN;
        const signals = signalsMatch ? parseInt(signalsMatch[1], 10) : NaN;
        const n = isNaN(constraints) ? 0 : constraints;
        const fftOrder = n > 0 ? Math.ceil(Math.log2(n)) : NaN;
        return { constraints, signals, fftOrder };
    } catch (e) {
        return { constraints: NaN, signals: NaN, fftOrder: NaN };
    }
}

/**
 * Ensure Circom compilation artefacts exist for a specific range size.
 * @param {number} rangeSize - Bit-width of the range proof circuit.
 * @returns {void} Generates `.r1cs` and wasm files when missing.
 */
function ensureCompiledArtifacts(rangeSize) {
    const r1csFile = `RangeProof_${rangeSize}.r1cs`;
    const wasmDir = `RangeProof_${rangeSize}_js`;
    const hasR1cs = fs.existsSync(r1csFile);
    const hasWasm = fs.existsSync(path.join(wasmDir, `RangeProof_${rangeSize}.wasm`));

    if (hasR1cs && hasWasm) return;

    // Táº¡o file circom táº¡m cho range báº¥t ká»³ (Num2Bits(rangeSize))
    const circomFile = `RangeProof_${rangeSize}.circom`;
    if (!fs.existsSync(circomFile)) {
        const circomSrc = [
            'pragma circom 2.0.4;',
            '',
            'include "circomlib/circuits/bitify.circom";',
            '',
            `template RangeProofN() {`,
            `    signal input x;`,
            `    component n2b = Num2Bits(${rangeSize});`,
            `    n2b.in <== x;`,
            `    signal output valid;`,
            `    valid <== 1;`,
            `}`,
            '',
            'component main = RangeProofN();',
            ''
        ].join('\n');
        fs.writeFileSync(circomFile, circomSrc);
    }

    // Compile báº±ng circom Ä‘á»ƒ táº¡o .r1cs vÃ  wasm
    const cmd = `circom ${circomFile} --r1cs --wasm --output . --O2`;
    execSync(cmd, { stdio: 'inherit' });
}

/**
 * Ensure a suitable Powers of Tau file exists, downloading it if necessary.
 * @param {number} rangeSize - Bit-width of the range proof circuit.
 * @returns {string} The `.ptau` filename ready for Groth16 setup.
 */
function ensurePtauFor(rangeSize) {
    // Æ¯á»›c lÆ°á»£ng fftOrder tá»« r1cs; chá»n power = max(14, fftOrder + 1)
    const { fftOrder } = getConstraintsAndFft(rangeSize);
    const power = Math.max(14, isNaN(fftOrder) ? 16 : (fftOrder + 1));
    const ptauName = `powersOfTau28_hez_final_${power}.ptau`;
    if (fs.existsSync(ptauName)) return ptauName;

    console.log(`   Downloading ${ptauName}...`);
    // Nguá»“n cÃ´ng khai thÆ°á»ng dÃ¹ng (Hermez/Polygon zkEVM mirrors)
    const urls = [
        `https://hermez.s3-eu-west-1.amazonaws.com/${ptauName}`,
        `https://storage.googleapis.com/zkevm/ptau/${ptauName}`
    ];

    let downloaded = false;
    for (const u of urls) {
        try {
            // Æ¯u tiÃªn curl náº¿u cÃ³, fallback PowerShell
            if (process.platform === 'win32') {
                execSync(`powershell -NoProfile -Command "try { Invoke-WebRequest -UseBasicParsing -Uri '${u}' -OutFile '${ptauName}' } catch { exit 1 }"`, { stdio: 'ignore' });
            } else {
                execSync(`curl -L -o "${ptauName}" "${u}"`, { stdio: 'ignore' });
            }
            downloaded = fs.existsSync(ptauName) && fs.statSync(ptauName).size > 0;
            if (downloaded) break;
        } catch (_) {
            // thá»­ URL tiáº¿p theo
        }
    }
    if (!downloaded) {
        throw new Error(`Cannot download ${ptauName}. Please place it in project root.`);
    }
    return ptauName;
}

/**
 * Ensure a witness file exists for the circuit by generating it on demand.
 * @param {number} rangeSize - Bit-width of the circuit.
 * @returns {Promise<string>} Absolute path to the witness file.
 */
async function ensureWitness(rangeSize) {
    const witnessFile = path.join(process.cwd(), `witness_${rangeSize}.wtns`);
    if (fs.existsSync(witnessFile)) return witnessFile;

    const inputPath = `input_${rangeSize}.json`;
    if (!fs.existsSync(inputPath)) {
        const max = BigInt(2) ** BigInt(rangeSize) - BigInt(1);
        const test = max > BigInt(Number.MAX_SAFE_INTEGER) ? BigInt(Number.MAX_SAFE_INTEGER) : max;
        fs.writeFileSync(inputPath, JSON.stringify({ x: test.toString() }));
    }

    await buildWitnessOnce(rangeSize, inputPath);
    return witnessFile;
}

// Äo tÃ¡ch pha vá»›i warm-up + iterations
async function measurePhasesWithStats(rangeSize, options) {
    const { iterations = 20, warmup = 5, inputPath = `input_${rangeSize}.json` } = options || {};
    const stats = {
        rangeSize,
        constraints: null,
        signals: null,
        fftOrder: null,
        witnessOnceMs: null,
        proveSamplesMs: [],
        verifySamplesMs: [],
        proveMedianMs: null,
        proveP95Ms: null,
        verifyMedianMs: null,
        verifyP95Ms: null
    };

    const { constraints, signals, fftOrder } = getConstraintsAndFft(rangeSize);
    stats.constraints = constraints;
    stats.signals = signals;
    stats.fftOrder = fftOrder;

    // chuáº©n bá»‹ input máº·c Ä‘á»‹nh náº¿u thiáº¿u
    if (!fs.existsSync(inputPath)) {
        const max = BigInt(2) ** BigInt(rangeSize) - BigInt(1);
        const test = max > BigInt(Number.MAX_SAFE_INTEGER) ? BigInt(Number.MAX_SAFE_INTEGER) : max;
        fs.writeFileSync(inputPath, JSON.stringify({ x: test.toString() }));
    }

    const t0 = process.hrtime.bigint();
    const witnessFile = await buildWitnessOnce(rangeSize, inputPath);
    const t1 = process.hrtime.bigint();
    stats.witnessOnceMs = Number(t1 - t0) / 1e6;

    const zkey = `circuit_${rangeSize}_final.zkey`;
    const proofFile = `proof_${rangeSize}.json`;
    const publicFile = `public_${rangeSize}.json`;
    const vkeyFile = `verification_key_${rangeSize}.json`;

    for (let i = 0; i < warmup; i++) {
        try {
            execSync(`snarkjs groth16 prove ${zkey} ${witnessFile} ${proofFile} ${publicFile}`, { stdio: 'pipe' });
            execSync(`snarkjs groth16 verify ${vkeyFile} ${publicFile} ${proofFile}`, { stdio: 'pipe' });
        } catch (e) {}
    }

    for (let i = 0; i < iterations; i++) {
        const s = process.hrtime.bigint();
        execSync(`snarkjs groth16 prove ${zkey} ${witnessFile} ${proofFile} ${publicFile}`, { stdio: 'pipe' });
        const e = process.hrtime.bigint();
        stats.proveSamplesMs.push(Number(e - s) / 1e6);
    }

    for (let i = 0; i < iterations; i++) {
        const s = process.hrtime.bigint();
        execSync(`snarkjs groth16 verify ${vkeyFile} ${publicFile} ${proofFile}`, { stdio: 'pipe' });
        const e = process.hrtime.bigint();
        stats.verifySamplesMs.push(Number(e - s) / 1e6);
    }

    stats.proveMedianMs = median(stats.proveSamplesMs);
    stats.proveP95Ms = p95(stats.proveSamplesMs);
    stats.verifyMedianMs = median(stats.verifySamplesMs);
    stats.verifyP95Ms = p95(stats.verifySamplesMs);

    return stats;
}

// HÃ m measure performance cho má»™t circuit
async function measureCircuitPerformance(rangeSize) {
    console.log(`\n${'='.repeat(70)}`);
    console.log(` MEASURING PERFORMANCE FOR RANGE PROOF ${rangeSize} BIT`);
    console.log(`${'='.repeat(70)}`);
    
    // Äáº£m báº£o cÃ³ artefacts cáº§n thiáº¿t trÆ°á»›c khi setup
    try {
        ensureCompiledArtifacts(rangeSize);
    } catch (e) {
        console.error(`   Failed to compile artifacts for RangeProof_${rangeSize}: ${e.message}`);
        return {
            rangeSize,
            provingKeySetupTime: null,
            provingKeyContributionTime: null,
            verificationKeyExportTime: null,
            proofGenerationTime: null,
            proofVerificationTime: null,
            totalProvingKeyTime: null,
            totalProofTime: null,
            totalVerificationTime: null,
            zkeySize: 0,
            proofSize: 0,
            publicSize: 0,
            verificationKeySize: 0
        };
    }

    const results = {
        rangeSize,
        provingKeySetupTime: null,
        provingKeyContributionTime: null,
        verificationKeyExportTime: null,
        proofGenerationTime: null,
        proofVerificationTime: null,
        totalProvingKeyTime: null,
        totalProofTime: null,
        totalVerificationTime: null,
        zkeySize: 0,
        proofSize: 0,
        publicSize: 0,
        verificationKeySize: 0
    };
    
    try {
        // 1. Generate proving key setup
        console.log(`\n1ï¸ Generating proving key setup...`);
        const ptauFile = ensurePtauFor(rangeSize);
        results.provingKeySetupTime = measureExecutionTime(
            `snarkjs groth16 setup RangeProof_${rangeSize}.r1cs ${ptauFile} circuit_${rangeSize}_0000.zkey`,
            `   Setting up groth16 for RangeProof_${rangeSize}`
        );
        
        if (results.provingKeySetupTime === null) {
            console.log(`  Skipping further steps for ${rangeSize}-bit circuit`);
            return results;
        }
        
        // 2. Contribute to proving key (with automatic entropy)
        console.log(`\n2ï¸ Contributing to proving key...`);
        const entropy = `random_entropy_${rangeSize}_${Date.now()}`;
        results.provingKeyContributionTime = measureExecutionTime(
            `echo "${entropy}" | snarkjs zkey contribute circuit_${rangeSize}_0000.zkey circuit_${rangeSize}_final.zkey --name="1" -v`,
            `   Contributing entropy to zkey`
        );
        
        if (results.provingKeyContributionTime === null) {
            console.log(`  Skipping further steps for ${rangeSize}-bit circuit`);
            return results;
        }
        
        // 3. Export verification key
        console.log(`\n3ï¸ Exporting verification key...`);
        results.verificationKeyExportTime = measureExecutionTime(
            `snarkjs zkey export verificationkey circuit_${rangeSize}_final.zkey verification_key_${rangeSize}.json`,
            `   Exporting verification key`
        );
        
        if (results.verificationKeyExportTime === null) {
            console.log(` Skipping further steps for ${rangeSize}-bit circuit`);
            return results;
        }
        
        // 4. Generate proof
        console.log(`\n4ï¸ Generating proof...`);
        await ensureWitness(rangeSize);
        results.proofGenerationTime = measureExecutionTime(
            `snarkjs groth16 prove circuit_${rangeSize}_final.zkey witness_${rangeSize}.wtns proof_${rangeSize}.json public_${rangeSize}.json`,
            `   Generating groth16 proof`
        );
        
        if (results.proofGenerationTime === null) {
            console.log(`âš ï¸  Skipping verification for ${rangeSize}-bit circuit`);
            return results;
        }
        
        // 5. Verify proof
        console.log(`\n5ï¸âƒ£ Verifying proof...`);
        results.proofVerificationTime = measureExecutionTime(
            `snarkjs groth16 verify verification_key_${rangeSize}.json public_${rangeSize}.json proof_${rangeSize}.json`,
            `   Verifying proof`
        );
        
        // Calculate total times
        results.totalProvingKeyTime = results.provingKeySetupTime + results.provingKeyContributionTime + results.verificationKeyExportTime;
        results.totalProofTime = results.proofGenerationTime;
        results.totalVerificationTime = results.proofVerificationTime;
        
        // Measure file sizes
        console.log(`\n6ï¸âƒ£ Measuring file sizes...`);
        try {
            results.zkeySize = fs.existsSync(`circuit_${rangeSize}_final.zkey`) ? fs.statSync(`circuit_${rangeSize}_final.zkey`).size : 0;
            results.proofSize = fs.existsSync(`proof_${rangeSize}.json`) ? fs.statSync(`proof_${rangeSize}.json`).size : 0;
            results.publicSize = fs.existsSync(`public_${rangeSize}.json`) ? fs.statSync(`public_${rangeSize}.json`).size : 0;
            results.verificationKeySize = fs.existsSync(`verification_key_${rangeSize}.json`) ? fs.statSync(`verification_key_${rangeSize}.json`).size : 0;
        } catch (error) {
            console.error(`   âŒ Error measuring file sizes: ${error.message}`);
        }
        
        console.log(`\nðŸ“ˆ Performance Summary for RangeProof_${rangeSize}:`);
        console.log(`   Proving key setup: ${results.provingKeySetupTime.toFixed(2)}ms`);
        console.log(`   Proving key contribution: ${results.provingKeyContributionTime.toFixed(2)}ms`);
        console.log(`   Verification key export: ${results.verificationKeyExportTime.toFixed(2)}ms`);
        console.log(`   Proof generation: ${results.proofGenerationTime.toFixed(2)}ms`);
        console.log(`   Proof verification: ${results.proofVerificationTime.toFixed(2)}ms`);
        console.log(`   Total proving key time: ${results.totalProvingKeyTime.toFixed(2)}ms`);
        console.log(`   Total proof time: ${results.totalProofTime.toFixed(2)}ms`);
        console.log(`   Total verification time: ${results.totalVerificationTime.toFixed(2)}ms`);
        console.log(`   ZKey size: ${(results.zkeySize / 1024).toFixed(2)} KB`);
        console.log(`   Proof size: ${(results.proofSize / 1024).toFixed(2)} KB`);
        console.log(`   Public size: ${(results.publicSize / 1024).toFixed(2)} KB`);
        console.log(`   Verification key size: ${(results.verificationKeySize / 1024).toFixed(2)} KB`);
        
    } catch (error) {
        console.error(`âŒ Error measuring performance for RangeProof_${rangeSize}:`, error.message);
    }
    
    return results;
}

// HÃ m chÃ­nh
async function main() {
    console.log('ðŸš€ Starting Proof Performance Measurement...\n');
    
    const allResults = [];
    
    for (const rangeSize of RANGE_SIZES) {
        const result = await measureCircuitPerformance(rangeSize);
        allResults.push(result);
        
        // Náº¿u circuit 64-bit Ä‘Ã£ cÃ³ sáºµn, chá»‰ cáº§n measure file sizes
        if (rangeSize === 64 && fs.existsSync(`proof_${rangeSize}.json`)) {
            console.log(`\nðŸ“Š Circuit 64-bit already has proof, measuring file sizes only...`);
            try {
                result.zkeySize = fs.existsSync(`circuit_64_final.zkey`) ? fs.statSync(`circuit_64_final.zkey`).size : 0;
                result.proofSize = fs.existsSync(`proof_64.json`) ? fs.statSync(`proof_64.json`).size : 0;
                result.publicSize = fs.existsSync(`public_64.json`) ? fs.statSync(`public_64.json`).size : 0;
                result.verificationKeySize = fs.existsSync(`verification_key_64.json`) ? fs.statSync(`verification_key_64.json`).size : 0;
                
                console.log(`   ZKey size: ${(result.zkeySize / 1024).toFixed(2)} KB`);
                console.log(`   Proof size: ${(result.proofSize / 1024).toFixed(2)} KB`);
                console.log(`   Public size: ${(result.publicSize / 1024).toFixed(2)} KB`);
                console.log(`   Verification key size: ${((result.verificationKeySize) / 1024).toFixed(2)} KB`);
            } catch (error) {
                console.error(`   âŒ Error measuring file sizes: ${error.message}`);
            }
        }

        // Äo tÃ¡ch pha witness/prove/verify (median/p95) náº¿u cÃ³ artefacts cáº§n thiáº¿t
        try {
            if (fs.existsSync(`circuit_${rangeSize}_final.zkey`) && fs.existsSync(`verification_key_${rangeSize}.json`)) {
                const defaultInputPath = `input_${rangeSize}.json`;
                if (!fs.existsSync(defaultInputPath)) {
                    const max = BigInt(2) ** BigInt(rangeSize) - BigInt(1);
                    const test = max > BigInt(Number.MAX_SAFE_INTEGER) ? BigInt(Number.MAX_SAFE_INTEGER) : max;
                    fs.writeFileSync(defaultInputPath, JSON.stringify({ x: test.toString() }));
                }
                await ensureWitness(rangeSize);
                result.phaseStats = await measurePhasesWithStats(rangeSize, { iterations: 20, warmup: 5, inputPath: defaultInputPath });
            }
        } catch (e) {
            // ignore phased measurement errors
        }
    }
    
    // Táº¡o bÃ¡o cÃ¡o tá»•ng há»£p
    console.log(`\n${'='.repeat(120)}`);
    console.log('ðŸ“Š COMPLETE PERFORMANCE SUMMARY');
    console.log(`${'='.repeat(120)}`);
    
    console.log('\nRange Size | Setup | Contribute | Export | Proof Gen | Verify | Total Setup | Total Proof | Total Verify');
    console.log('-----------|-------|------------|--------|-----------|--------|-------------|-------------|-------------');
    
    for (const result of allResults) {
        if (result.totalProvingKeyTime !== null) {
            console.log(`${result.rangeSize.toString().padStart(10)} | ${result.provingKeySetupTime?.toFixed(0).padStart(5)} | ${result.provingKeyContributionTime?.toFixed(0).padStart(10)} | ${result.verificationKeyExportTime?.toFixed(0).padStart(6)} | ${result.proofGenerationTime?.toFixed(0).padStart(9)} | ${result.proofVerificationTime?.toFixed(0).padStart(6)} | ${result.totalProvingKeyTime?.toFixed(0).padStart(11)} | ${result.totalProofTime?.toFixed(0).padStart(11)} | ${result.totalVerificationTime?.toFixed(0).padStart(11)}`);
        } else {
            console.log(`${result.rangeSize.toString().padStart(10)} | ${'N/A'.padStart(5)} | ${'N/A'.padStart(10)} | ${'N/A'.padStart(6)} | ${'N/A'.padStart(9)} | ${'N/A'.padStart(6)} | ${'N/A'.padStart(11)} | ${'N/A'.padStart(11)} | ${'N/A'.padStart(11)}`);
        }
    }
    
    console.log('\nRange Size | ZKey (KB) | Proof (KB) | Public (KB) | VKey (KB)');
    console.log('-----------|------------|------------|-------------|-----------');
    
    for (const result of allResults) {
        console.log(`${result.rangeSize.toString().padStart(10)} | ${(result.zkeySize / 1024).toFixed(0).padStart(10)} | ${(result.proofSize / 1024).toFixed(0).padStart(10)} | ${(result.publicSize / 1024).toFixed(0).padStart(11)} | ${(result.verificationKeySize / 1024).toFixed(0).padStart(8)}`);
    }
    
    // In thá»‘ng kÃª tÃ¡ch pha náº¿u cÃ³
    console.log(`\n${'='.repeat(120)}`);
    console.log('ðŸ§ª PHASED MEASUREMENTS (witness once, prove/verify median & p95)');
    console.log(`${'='.repeat(120)}`);
    for (const r of allResults) {
        if (!r.phaseStats) continue;
        const p = r.phaseStats;
        console.log(`\nRangeProof_${r.rangeSize}: constraints=${p.constraints}, signals=${p.signals}, fftOrderâ‰ˆ${p.fftOrder}`);
        console.log(`   Witness once: ${p.witnessOnceMs?.toFixed(2)} ms`);
        console.log(`   Prove median/p95: ${p.proveMedianMs?.toFixed(2)} / ${p.proveP95Ms?.toFixed(2)} ms`);
        console.log(`   Verify median/p95: ${p.verifyMedianMs?.toFixed(2)} / ${p.verifyP95Ms?.toFixed(2)} ms`);
    }

    // LÆ°u káº¿t quáº£
    const summary = {
        timestamp: new Date().toISOString(),
        results: allResults
    };
    
    fs.writeFileSync('proof_performance_results.json', JSON.stringify(summary, null, 2));
    console.log('\nðŸ’¾ Results saved to proof_performance_results.json');
    
    return allResults;
}

// Cháº¡y script
if (require.main === module) {
    main().catch(error => {
        console.error('Error:', error);
    });
}

module.exports = { measureCircuitPerformance, main, measurePhasesWithStats };
